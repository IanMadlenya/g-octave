#!/usr/bin/env python
# -*- coding: utf-8 -*-

from config import Config
conf = Config()

from description import *
from description_tree import *

import re

class EbuildException(Exception):
    pass

class Ebuild:
    
    def __init__(self, pkg_atom):
        
        self.__dbtree = DescriptionTree()
        
        atom = re_pkg_atom.match(pkg_atom)
        if atom == None:
            self.pkgname = pkg_atom
            self.version = self.__dbtree.latest_version(self.pkgname)
        else:
            self.pkgname = atom.group(1)
            self.version = atom.group(2)
        
        self.__desc = self.__dbtree['%s-%s' % (self.pkgname, self.version)]
        
        if self.__desc == None:
            raise EbuildException('Package not found: %s' % pkg_atom)

    def create(self):
        
        overlay = conf.overlay
        ebuild_path = os.path.join(overlay, 'g-octave', self.pkgname)
        if not os.path.exists(ebuild_path):
            os.makedirs(ebuild_path, 0755)
        
        ebuild = """\
# Copyright 1999-2009 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# This ebuild generated by g-octave

EAPI="2"

inherit octave-forge

DESCRIPTION="%(description)s"
HOMEPAGE="%(url)s"
SRC_URI="mirror://sourceforge/octave/${OCT_P}.tar.gz"

LICENSE="|| ( GPL-2 GPL-3 LGPL BSD GFDL )"
SLOT="0"
KEYWORDS="%(keywords)s"
IUSE=""

DEPEND="%(depend)s"
RDEPEND="${DEPEND}
\t%(rdepend)s"
"""
        
        vars = {
            'description': self.__desc.description,
            'url': self.__desc.url,
            'keywords': '~x86', # for tests
            'depend': '',
            'rdepend': '',
        }
        
        vars['depend']   = self.depends(self.__desc.buildrequires)
        vars['rdepend']  = self.depends(self.__desc.depends)
        vars['rdepend'] += "\n\t"+self.depends(self.__desc.systemrequirements)
        
        fp = open(os.path.join(ebuild_path, '%s-%s.ebuild' % (self.pkgname, self.version)), 'w')
        fp.write(ebuild % vars)
        fp.close()
        
        self.__resolve_dependencies()
        
    
    def depends(self, mylist):
        
        if mylist != None:
            return "\n\t".join(mylist)
        
        return ''


    def __resolve_dependencies(self):
        
        to_install = []
        
        for pkg, comp, version in self.__desc.self_depends:
            
            # no version required, get the latest available
            if version == None:
                to_install.append('%s-%s' % (pkg, self.__dbtree.latest_version(pkg)))
                continue
            
            # here we need to calculate the better version to install
            versions = self.__dbtree.package_versions(pkg)
            
            allowed_versions = []
            
            for _version in versions:
                _tp_version = tuple(_version.split('.'))
                tp_version = tuple(version.split('.'))
                
                if eval('%s %s %s' % (_tp_version, comp, tp_version)):
                    allowed_versions.append(_version)
                
            to_install.append('%s-%s' % (pkg, self.__dbtree.version_compare(allowed_versions)))
        
        # creating the ebuilds for the dependencies, recursivelly
        for ebuild in to_install:
            Ebuild(ebuild).create()


if __name__ == '__main__':
    a = Ebuild('signal')
    a.create()
